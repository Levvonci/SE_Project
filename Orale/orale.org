#+Title: Orale ing del software
#+Author: Leonardo Ascenzi

* Significato include/exclude negli use case
  Il diagramma degli use case permettere di rappresentare graficamente le interazioni tra attori e sistema, specificando quali casi d'uso gli attori possono attivare.
** Include:
Indica che un caso d'uso include **obbligatoriamente** un altro caso d'uso per completare la sua funzionalitá.
Utilizzato quando il comportamento di un caso d'uso é riutilizzabile per altri casi d'uso.
Caso d'uso principale richiede l'esecuzione dei casi d'uso inclusi.

** Extend:
Indica che un caso d'uso puó estendere **opzionalmente** un altro caso d'uso, aggiungendo funzionalitá alternative o opzionali.
Utilizzato per rappresentare casi che si verificano solo in determinate condizioni.
L'attivazione del caso d'uso esteso dipende da una determinata condizione.

* Requisiti Software
I requisiti del software sono la **descrizione dei servizi** che un sistema software deve fornire, insieme ai vincoli da rispettare sia in fase di sviluppo che durante la fase di operativitá.

** Requisiti utente:
Descrizione in **linguaggio naturale** dei **servizi** che il sistema deve fornire e dei **vincoli operativi**.

** Requisiti di sistema:
Specificati mediante la **stesura di un documento strutturato** che descrive in modo dettagliato i **servizi che il sistema software deve fornire**.
Si dividono in **3** categorie:

*** Funzionali:
Definiscono le funzionalitá del sistema, ovvero i servizi offerti, le reazioni a specifici input e il comportamento in diverse situazioni operative.

*** Non funzionali:
Descrivono le qualitá del sistema e del processo di sviluppo, come efficienza, affidabilitá, sicurezza ed altre caratteristiche esterne.

*** Dominio:
Derivano dal contesto applicativo del sistema.

** Differenze:
I requisiti funzionali in breve **definiscono** tutte le **operazioni** che il **sistema deve eseguire**.
Gli altri **definiscono** tutte le **funzionalitá** che il **sistema deve rispettare**.

* Modello ciclo di vita
Definisce le fasi attraverso cui il prodotto software evolve, dalla raccolta dei requisiti alla dismissione e l'ordine in cui tali fasi vengono eseguite.
La scelta del modello dipende da fattori come la natura e la maturitá dell'organizzazione, le tecnologie adottate e i vincoli del cliente.

** Principali modelli
*** Build & Fix
Modello privo di struttura formale; il prodotto viene sviluppato e poi modificato fino a soddisfare le esigenze del cliente.

*** Waterfall
Modello sequenziale a fasi successive copn verifica alla fine di ogni fase; adatto a progetti con requisiti ben definiti.

*** Spirale
Modello iterativo che combina l'approccio del Waterfall con una forte enfasi sull'analisi dei rischi; ideale per progetti complessi e soggetti a cambiamenti nei requisiti.

* Risk Analysis
È il processo di identificazione, valutazione e gestione dei potenziali problemi che possono compromettere il successo di un progetto software.

** Fasi principali:
1. Identificazione dei rischi:
   Individuare tutte le minacce che possono influire negativamente sul progetto.

2. Valutazione dei rischi:
   Stimare l'impatto e la probabilitá di ogni rischio.

3. Prioritizzazione:
   Stabilire quali rischi gestire per primi.

4. Pianificazione delle mitigazioni:
   Definire le azioni per ridurre la probabilitá o l'impatto dei rischi.

5. Monitoraggio continuo:
   Assicurarsi che i rischi siano monitorati durante tutto il ciclo di vita del software.

* Architettura software - Architettura oggetti distribuiti
L'architettura di sistema definisce la struttura dei componenti del sistema software, insieme alle relazioni tra questi ultimi.
L'architettura ad oggetti distribuiti é un'architettura di sistema che non fa distinzioni tra client/server, infatti ogni oggetto distribuito puó fungere sia da client che da server.
La comunicazione remota fra gli oggetti é resa trasparente usando middleware basati sul concetto di software bus.
Le applicazioni basate su questa architettura consistono in un insieme di oggetti che sono eseguiti su piattaforme distribuite ed eterogenee, e comunicano tramite invocazioni remote dei metodi.

* ORB - Object Request Broker
É un componente middleware che abilita la comunicazione trasparente tra oggetti distribuiti su rete, indipendentemente da posizione fisica, linguaggio di programmazione o sistema operativo
É il cuore delle architetture ad oggetti distribuiti, come CORBA.

** Funzionamento
**Intermediazione Richieste:** il client invoca un metodo su un oggetto remoto; ORB localizza il server, inoltra la richiesta e restituisce il risultato.
**Gestione Dati:** si occupa di serializzazione e deserializzaziopne dei parametri, oltre ai protocolli di rete
**Trasparenze Fornite:** location trasparency e implementation trasparency.

** Vantaggi
Permette agli sviluppatori di concentrarsi sulla logica applicativa, astraendo la complessitá della distribuzione.

* Relazione tra prodotto e costo di produzione
La relazione tra prodotto software e costo di produzione é prevalentemente positiva: maggiore é la dimensione, la complessitá o la qualitá del prodotto, maggiore é il costo iniziale di sviluppo, ma con impatti variabili sui costi a lungo termine.

** Fattori principali
**Dimensione del prodotto:** La complessitá e le funzionalitá aumentano direttamente lo sforzo e i costi, spesso in modo non lineare.
**Qualitá:** Investire in qualitá eleva i costi iniziali, ma riduce quelli futuri di manutenzione e correzioni.
**Processi di sviluppo:** Metodologie efficienti e automazione abbassano i costi mantenendo la qualitá

** Equilibrio costi
**Scalabilitá e modularitá:** Favoriscono costi minori in fase di aggiornamenti e manutenzioni, bilanciando l'investimento iniziale.
**Sintesi:** Esiste un trade-off tra costi di produzione upfront e spese post-rilascio, ottimizzabile con stime accurate basate su dimensioni funzionali.

* Service Oriented Architecture
La SOA é un'architettura software distribuita che consiste in molteplici servizi.
I Servizi sono distribuiti in maniera tale da poter essere eseguiti su nodi differenti con differenti service provider.
L'obiettivo é quello di sviluppare applicazioni software composte da servizi distribuiti, in modo tale che i singoli servizi possano essere eseguiti su piú piattaforme differenti e implementati con differenti linguaggi di programmazione
All'interno delle SOA troviamo ORB che permette la comunicazione tra i client e i servizi distribuiti.

Il fulcro dell'implementazione SOA sono i web services, e sfruttano vari protocolli per far comunicare i servizi fra di loro.

Tra questi troviamo:
**SOAP:** protocollo basato su XML e HTML che permette lo scambio di informazioni in un sistema distribuito. Utilizza protocolli di trasporto come HTTP, SMTP.
**REST:** architettura che utilizza i metodi HTML per operazioni CRUD.

Oltre che ai web services, le SOA utilizzano altri servizi, tra cui:
**UDDI:** aiuta a localizzare e identificare i servizi presenti in una rete.
**WSDL:** Linguaggio basato su XML utilizzato per descrivere le interfacce dei servizi in un'architettura di SOA.

* Secondo quali attivitá va declinata la fase di testing?
La fase di testing é articolata in una serie di attivitá che assicurano la soddisfazione dei requisiti definiti.
Queste attivitá sono:

1. **Pianificazione del testing:**
   - Definizione degli obiettivi del testing.
   - Identificazione delle risorse necessarie.
   - Pianificazione temporale e stima dei costi.
2. **Progettazione dei Test Case:**
   - Creazione di scenari di test basati sui requisiti funzionali e non funzionali.
   - Identificazione delle versioni software da testare.
3. **Preparazione dell'ambiente di test:**
   - Configurazione degli ambienti (Hardware, Software, Reti). 
   - Installazione delle versioni del software da testare. 
4. **Esecuzione dei test:**
   - Esecuzione dei casi di test progettati. 
   - Registrazione dei risultati (Successo o Fallimento) e documentazione delle anomalie.
5. **Analisi dei risultati:**
   - Confronto tra risultati ottenuti e quelli attesi.
   - Identificazione e classificazione dei difetti.
6. **Risoluzione dei problemi:**
   - Collaborazione con il team di sviluppo per risolvere i difetti identificati.
   - Verifica delle correzioni.
7. **Test di regressione:**
   - Assicurarsi che le modifiche al codice non abbiano introdotto nuovi errori.
8. **Valutazione finale e report:**
   - Verifica se il prodotto soddisfa i criteri di accettazione.
   - Redazione di un report con le conclusioni del testing.

* Come si chiama il testing di validazione per i software a contratto?
Il testing di validazione per i software a contratto é chiamato **Acceptance Testing.**
- **Definizione:**
  É l'utlima fase del ciclo di testing, in cui il cliente o l'utente finale verifica che il software soddisfi i requisiti contrattuali e sia pronto per il rilascio.
- **Scopo:**
  Validare che il software sia conforme alle specifiche contrattuali e garantire la piena utilizabilitá nel contesto operativo del cliente.

* Ciclo di vita del Software
** Definizione Formale
Il ciclo di vita di un software é il quadro strutturale che organizza in fasi, attivitá e compiti tutti i processi di sviluppo, esericizo e manutenzione di un prodotto software, dalla definizione dei requisiti fino alla dismissione del sistema.
É suddiviso in 3 stadi, il primo stadio a sua volta é composto da 6 fasi.
** Stadi
*** Stadio 1: Sviluppo
- Requisiti
- Specifiche
- Pianificazione
- Progetto
- Codifica
- Integrazione

*** Stadio 2: Manutenzione
Copre circa il 60% dei costi del ciclo di vita

*** Stadio 3: Dismissione

** Fasi dello Stadio di Sviluppo
*** 1. Requisiti
**Obiettivo:** Identificare e raccogliere le esigenze degli stakeholder.
**Descrizione:** In questa fase si effettua la raccolta, l'analisi e la documentazione dettagliata delle esigenze degli utenti e degli stakeholder, per definire cosa il sistema deve fare e i suoi vincoli operativi.
**Attivitá Principali:**
- Interviste con utenti e clienti.
- Analisi delle esigenze funzionali.
- Identificazione dei requisiti non funzionali.
- Creazione di una lista iniziale di requisiti.

*** 2. Specifiche
**Obiettivo:** Documentare e dettagliare i requisiti raccolti nella fase precedente.
**Descrizione:** Approfondisce i requisiti in specifiche tecniche dettagliate, producendo documenti come **SRS (Software Require Specification)** o **SFS (Software Functional Specification)** che serviranno nelle fasi successive.
**Attivitá Principali:**
- Analisi di fattibilitá tecnica ed economica.
- Stesura dei documenti di specifiche.
- Validazione dei requisiti con il cliente per verificare che siano corretti.

*** 3. Pianificazione
**Obiettivo:** Organizzare il lavoro per il completamento del progetto.
**Descrizione:** Si definisce il piano del progetto: stime di costi/risorse/tempi, allocazione team, scelta strumenti/metodologie, identificazione rischi e definizione milestone. Produce il **Project Plan** con *Gant*, budget e criteri di monitoraggio. É cruciale per allineare stakeholder e gesstire scope.

*** 4. Progetto
**Obiettivo:** Progettare l'architettura e i dettagli tecnici del software.
**Descrizione:** Si definisce la struttura del sistema e le componenti, fornendo un modello chiaro da seguire nella fase di sviluppo.
**Attivitá Principali:**
- Progettazione dell'architettura.
- Creazione dei diagrammi UML, diagrammi di flusso e design delle interfacce.
- Progettazione di database e definizione delle entitá.
- Redazione del piano di test iniziale per assicurarsi cjhe il progetto sia verificabile.

*** 5. Codifica
**Obiettivo:** Tradurre il design in un software funzionante.
**Descrizione:** In questa fase gli sviluppatori scrivono il codice sorgente seguendo le specifiche di progetto, standard di coding e best practice. Include unit testing durante lo sviluppo e commit in repository git. L'importanza di questa fase é per l'appunto la trasformazione da design a eseguibile, con enfasi su qualitá e leggibilitá.

*** 6. Integrazione
**Obiettivo:** Collegare i diversi moduli e testare il sistema completo.
**Descrizione:** SI assemblano i moduli/test unitari in un sistema coerente, verificando integrazioni tramite test di integrazione. Identifica e risolve difetti di interfaccia. Culmina in unn  prototipo parziale o completo pronto per essere testato.

* Qual é la manutenzione piú frequentemente utilizzata?
La manutenzione piú frequentemente utilizzata é quella **correttiva**.
La manutenzione correttiva é l'insieme delle attivitá volte a correggere difetti, errori o malfunzionamenti riscontrati nel software dopo il suo rilascio in produzione, ripristinando la funzionalitá conforme alle specifiche originali.

** Altri tipi di manutenzioni
**** Adattiva
Modifiche al software per adattarlo ai cambiamenti dell'ambiente operativo.

**** Perfettiva
Migliora le prestazioni o aggiunge nuove funzionalitá per soddisfare le richieste degli utenti.

**** Preventiva
Effettuare modifiche per ridurre richi di guasto o per prevenire dei problemi futuri.

* Regola 10-90
La regola 10-90 é una variante della regola 90-90, un aforismo umoristico dell'ingegneria del software.
Questa regola afferma che: "Solo il 10% del codice critico consuma il 90% delle risorse di esecuzione o sviluppo".
Il 10% del codice in questione si definisce **core** del programma.

* Stima durata progetto
Per stimare la durata totale di un progetto software partendo dal documento di specifica, é necessario utilizzare tecniche di pianificazione e stima che si basano su dioversi fattori come la dimensione stimata del prodotto, le risorse disponibili e i processi di sviluppo.
La prima fase della stima é quella stimare le dimensioni totali del software. usando tecniche note che vedremo avanti.
Successivamente si stima la durata:
1. Modello algoritmico **COCOMO:**
   - Stimando effort e poi tempo
2. Usando metodi empirici:
   - Suddividere il progetto in attivitá specifiche e stimare la durata di goni attivitá e successivamente sommare tutte queste stime per averne una complessiva.

* Organizzazione modello di qualitá del Software
Il modello di qualitá del software si strutturs principalmente attorno allo standard **IEEE 1061**, che fonrnisce un framework sistematico per definire, misurare e valutare la qualitá attraverso metriche quantitative legate a obiettivi specifici del progetto.

** Principi e struttura secondo IEEE 1061
Lo standard organizza la qualitá del software identificando prima gli obiettivi di qualitá rilevanti per il contesto.
Successivamente, associa a questi obiettivi attributi di qualitá misurabili e metriche per valutarli.
Un elemento centrale sono gli indici di qualitá, che aggregano piú metriche in indicatori sintetici per monitorare le prestazioni complessive.
Questi indici si divono in tre gruppi principali, allineati al modello McCall.

*** 1. Attivitá di Revisione
- **Manutenibilitá:** effort richiesto per individuare e correggere un errore in un programma operativo.
- **Flessibilitá:** effort per modificare un prodotto software giá in uso.
- **Testabilitá:** effort per testare il software e verificarne la correttezza funzionale.

*** 2. Attivitá di Transizione
- **Portabilitá:** effort per traferire il software ad un nuovo ambiente hardware/software.
- **Riusabilitá:** grado in cui parti del software possono essere riutilizzate in altre applicazioni.
- **Interoperabilitá:** effort per integrare il software con altri sistemi.
- **Evolutivitá:** effort per aggiornarlo con nuovi requisiti.

*** 3. Attivitá di Operazioni
- **Correttezza:** misura in cui il software soddisfa specifiche e obiettivi utente.
- **Affidabilitá:** probabilmente che svolga le funzioni previste con la precisione richiesta.
- **Efficienza:** risorse di calcolo e codice necessarie per eseguire una funzione.
- **Integritá:** protezione da accessi non autorizzati a software o dati.
- **Usabilitá:** effort per imparere, usare, preparare input e interpretare output.

*** Attributi di qualitá
Oltre aghli indici, **IEEE 1061** elenca attributi fondamentali, come:
- **Complessitá:** comprensibilitá e verificabilitá degli elementi e delle loro interazioni.
- **Precisione:** accuratezza dei calcoli e e risultati.
- **Completezza:** implementazione esaustiva delle funzionalità richieste.
- **Coerenza:** uniformità di design, implementazione e notazioni.
- **Tolleranza:** capacità di operare in condizioni avverse.
- **Tracciabilitá:** legami chiari tra elementi del processo di sviluppo.
- **Espandibilitá:** possibilità di ampliare memorie o funzioni.
- **Generalitá:** ampiezza delle applicazioni potenziali.
- **Modularitá:** indipendenza dei moduli.
- **Autodocumentazione:** presenza di documentazione inline.

Questi attribuit sono mappati su metriche concrete

*** Processo iterativo di valutazione
IEEE 1061 definisce un ciclo chiaro:
1. **Definizione degli obiettivi:** contestualizzati al progetto.
2. **Identificazione degli attributi:** selezione di quelli prioritari.
3. **Scelta metriche:** quantitative e rilevanti per ciascun attributo.
4. **Misurazione:** calcolo e confronto con benchmark o target.
5. **Analisi e Feedback:** miglioramento continuo basato sui risultati.

Questa struttura garantisce che la qualitá sia oggettiva, misurabile e allineata agli stakeholder, riducendo soggettivitá e rischi.
