#+Title: Orale ing del software
#+Author: Leonardo Ascenzi

* Significato include/exclude negli use case
Il diagramma degli use case permettere di rappresentare graficamente le interazioni tra attori e sistema, specificando quali casi d'uso gli attori possono attivare.

** Include:
Indica che un caso d'uso include **obbligatoriamente** un altro caso d'uso per completare la sua funzionalitá.
Utilizzato quando il comportamento di un caso d'uso é riutilizzabile per altri casi d'uso.
Caso d'uso principale richiede l'esecuzione dei casi d'uso inclusi.

** Extend:
Indica che un caso d'uso puó estendere **opzionalmente** un altro caso d'uso, aggiungendo funzionalitá alternative o opzionali.
Utilizzato per rappresentare casi che si verificano solo in determinate condizioni.
L'attivazione del caso d'uso esteso dipende da una determinata condizione.

* Requisiti Software
I requisiti del software sono la **descrizione dei servizi** che un sistema software deve fornire, insieme ai vincoli da rispettare sia in fase di sviluppo che durante la fase di operativitá.

** Requisiti utente:
Descrizione in **linguaggio naturale** dei **servizi** che il sistema deve fornire e dei **vincoli operativi**.

** Requisiti di sistema:
Specificati mediante la **stesura di un documento strutturato** che descrive in modo dettagliato i **servizi che il sistema software deve fornire**.
Si dividono in **3** categorie:

*** Funzionali:
Definiscono le funzionalitá del sistema, ovvero i servizi offerti, le reazioni a specifici input e il comportamento in diverse situazioni operative.

*** Non funzionali:
Descrivono le qualitá del sistema e del processo di sviluppo, come efficienza, affidabilitá, sicurezza ed altre caratteristiche esterne.

*** Dominio:
Derivano dal contesto applicativo del sistema.

** Differenze:
I requisiti funzionali in breve **definiscono** tutte le **operazioni** che il **sistema deve eseguire**.
Gli altri **definiscono** tutte le **funzionalitá** che il **sistema deve rispettare**.

* Modello ciclo di vita
Definisce le fasi attraverso cui il prodotto software evolve, dalla raccolta dei requisiti alla dismissione e l'ordine in cui tali fasi vengono eseguite.
La scelta del modello dipende da fattori come la natura e la maturitá dell'organizzazione, le tecnologie adottate e i vincoli del cliente.

** Principali modelli
*** Build & Fix
Modello privo di struttura formale; il prodotto viene sviluppato e poi modificato fino a soddisfare le esigenze del cliente.

*** Waterfall
Modello sequenziale a fasi successive copn verifica alla fine di ogni fase; adatto a progetti con requisiti ben definiti.

*** Spirale
Modello iterativo che combina l'approccio del Waterfall con una forte enfasi sull'analisi dei rischi; ideale per progetti complessi e soggetti a cambiamenti nei requisiti.

* Risk Analysis
È il processo di identificazione, valutazione e gestione dei potenziali problemi che possono compromettere il successo di un progetto software.

** Fasi principali:
1. Identificazione dei rischi:
   Individuare tutte le minacce che possono influire negativamente sul progetto.

2. Valutazione dei rischi:
   Stimare l'impatto e la probabilitá di ogni rischio.

3. Prioritizzazione:
   Stabilire quali rischi gestire per primi.

4. Pianificazione delle mitigazioni:
   Definire le azioni per ridurre la probabilitá o l'impatto dei rischi.

5. Monitoraggio continuo:
   Assicurarsi che i rischi siano monitorati durante tutto il ciclo di vita del software.

* Architettura software - Architettura oggetti distribuiti
L'architettura di sistema definisce la struttura dei componenti del sistema software, insieme alle relazioni tra questi ultimi.
L'architettura ad oggetti distribuiti é un'architettura di sistema che non fa distinzioni tra client/server, infatti ogni oggetto distribuito puó fungere sia da client che da server.
La comunicazione remota fra gli oggetti é resa trasparente usando middleware basati sul concetto di software bus.
Le applicazioni basate su questa architettura consistono in un insieme di oggetti che sono eseguiti su piattaforme distribuite ed eterogenee, e comunicano tramite invocazioni remote dei metodi.

* ORB - Object Request Broker
É un componente middleware che abilita la comunicazione trasparente tra oggetti distribuiti su rete, indipendentemente da posizione fisica, linguaggio di programmazione o sistema operativo
É il cuore delle architetture ad oggetti distribuiti, come CORBA.

** Funzionamento
**Intermediazione Richieste:** il client invoca un metodo su un oggetto remoto; ORB localizza il server, inoltra la richiesta e restituisce il risultato.
**Gestione Dati:** si occupa di serializzazione e deserializzaziopne dei parametri, oltre ai protocolli di rete
**Trasparenze Fornite:** location trasparency e implementation trasparency.

** Vantaggi
Permette agli sviluppatori di concentrarsi sulla logica applicativa, astraendo la complessitá della distribuzione.

* Relazione tra prodotto e costo di produzione
La relazione tra prodotto software e costo di produzione é prevalentemente positiva: maggiore é la dimensione, la complessitá o la qualitá del prodotto, maggiore é il costo iniziale di sviluppo, ma con impatti variabili sui costi a lungo termine.

** Fattori principali
**Dimensione del prodotto:** La complessitá e le funzionalitá aumentano direttamente lo sforzo e i costi, spesso in modo non lineare.
**Qualitá:** Investire in qualitá eleva i costi iniziali, ma riduce quelli futuri di manutenzione e correzioni.
**Processi di sviluppo:** Metodologie efficienti e automazione abbassano i costi mantenendo la qualitá

** Equilibrio costi
**Scalabilitá e modularitá:** Favoriscono costi minori in fase di aggiornamenti e manutenzioni, bilanciando l'investimento iniziale.
**Sintesi:** Esiste un trade-off tra costi di produzione upfront e spese post-rilascio, ottimizzabile con stime accurate basate su dimensioni funzionali.

* Service Oriented Architecture
La SOA é un'architettura software distribuita che consiste in molteplici servizi.
I Servizi sono distribuiti in maniera tale da poter essere eseguiti su nodi differenti con differenti service provider.
L'obiettivo é quello di sviluppare applicazioni software composte da servizi distribuiti, in modo tale che i singoli servizi possano essere eseguiti su piú piattaforme differenti e implementati con differenti linguaggi di programmazione
All'interno delle SOA troviamo ORB che permette la comunicazione tra i client e i servizi distribuiti.

Il fulcro dell'implementazione SOA sono i web services, e sfruttano vari protocolli per far comunicare i servizi fra di loro.

Tra questi troviamo:
**SOAP:** protocollo basato su XML e HTML che permette lo scambio di informazioni in un sistema distribuito. Utilizza protocolli di trasporto come HTTP, SMTP.
**REST:** architettura che utilizza i metodi HTML per operazioni CRUD.

Oltre che ai web services, le SOA utilizzano altri servizi, tra cui:
**UDDI:** aiuta a localizzare e identificare i servizi presenti in una rete.
**WSDL:** Linguaggio basato su XML utilizzato per descrivere le interfacce dei servizi in un'architettura di SOA.

* Secondo quali attivitá va declinata la fase di testing?
La fase di testing é articolata in una serie di attivitá che assicurano la soddisfazione dei requisiti definiti.
Queste attivitá sono:

1. **Pianificazione del testing:**
   - Definizione degli obiettivi del testing.
   - Identificazione delle risorse necessarie.
   - Pianificazione temporale e stima dei costi.
2. **Progettazione dei Test Case:**
   - Creazione di scenari di test basati sui requisiti funzionali e non funzionali.
   - Identificazione delle versioni software da testare.
3. **Preparazione dell'ambiente di test:**
   - Configurazione degli ambienti (Hardware, Software, Reti). 
   - Installazione delle versioni del software da testare. 
4. **Esecuzione dei test:**
   - Esecuzione dei casi di test progettati. 
   - Registrazione dei risultati (Successo o Fallimento) e documentazione delle anomalie.
5. **Analisi dei risultati:**
   - Confronto tra risultati ottenuti e quelli attesi.
   - Identificazione e classificazione dei difetti.
6. **Risoluzione dei problemi:**
   - Collaborazione con il team di sviluppo per risolvere i difetti identificati.
   - Verifica delle correzioni.
7. **Test di regressione:**
   - Assicurarsi che le modifiche al codice non abbiano introdotto nuovi errori.
8. **Valutazione finale e report:**
   - Verifica se il prodotto soddisfa i criteri di accettazione.
   - Redazione di un report con le conclusioni del testing.

* Come si chiama il testing di validazione per i software a contratto?
Il testing di validazione per i software a contratto é chiamato **Acceptance Testing.**
- **Definizione:**
  É l'utlima fase del ciclo di testing, in cui il cliente o l'utente finale verifica che il software soddisfi i requisiti contrattuali e sia pronto per il rilascio.
- **Scopo:**
  Validare che il software sia conforme alle specifiche contrattuali e garantire la piena utilizabilitá nel contesto operativo del cliente.

* Ciclo di vita del Software
** Definizione Formale
Il ciclo di vita di un software é il quadro strutturale che organizza in fasi, attivitá e compiti tutti i processi di sviluppo, esericizo e manutenzione di un prodotto software, dalla definizione dei requisiti fino alla dismissione del sistema.
É suddiviso in 3 stadi, il primo stadio a sua volta é composto da 6 fasi.
** Stadi
*** Stadio 1: Sviluppo
- Requisiti
- Specifiche
- Pianificazione
- Progetto
- Codifica
- Integrazione

*** Stadio 2: Manutenzione
Copre circa il 60% dei costi del ciclo di vita

*** Stadio 3: Dismissione

** Fasi dello Stadio di Sviluppo
*** 1. Requisiti
**Obiettivo:** Identificare e raccogliere le esigenze degli stakeholder.
**Descrizione:** In questa fase si effettua la raccolta, l'analisi e la documentazione dettagliata delle esigenze degli utenti e degli stakeholder, per definire cosa il sistema deve fare e i suoi vincoli operativi.
**Attivitá Principali:**
- Interviste con utenti e clienti.
- Analisi delle esigenze funzionali.
- Identificazione dei requisiti non funzionali.
- Creazione di una lista iniziale di requisiti.

*** 2. Specifiche
**Obiettivo:** Documentare e dettagliare i requisiti raccolti nella fase precedente.
**Descrizione:** Approfondisce i requisiti in specifiche tecniche dettagliate, producendo documenti come **SRS (Software Require Specification)** o **SFS (Software Functional Specification)** che serviranno nelle fasi successive.
**Attivitá Principali:**
- Analisi di fattibilitá tecnica ed economica.
- Stesura dei documenti di specifiche.
- Validazione dei requisiti con il cliente per verificare che siano corretti.

*** 3. Pianificazione
**Obiettivo:** Organizzare il lavoro per il completamento del progetto.
**Descrizione:** Si definisce il piano del progetto: stime di costi/risorse/tempi, allocazione team, scelta strumenti/metodologie, identificazione rischi e definizione milestone. Produce il **Project Plan** con *Gant*, budget e criteri di monitoraggio. É cruciale per allineare stakeholder e gesstire scope.

*** 4. Progetto
**Obiettivo:** Progettare l'architettura e i dettagli tecnici del software.
**Descrizione:** Si definisce la struttura del sistema e le componenti, fornendo un modello chiaro da seguire nella fase di sviluppo.
**Attivitá Principali:**
- Progettazione dell'architettura.
- Creazione dei diagrammi UML, diagrammi di flusso e design delle interfacce.
- Progettazione di database e definizione delle entitá.
- Redazione del piano di test iniziale per assicurarsi cjhe il progetto sia verificabile.

*** 5. Codifica
**Obiettivo:** Tradurre il design in un software funzionante.
**Descrizione:** In questa fase gli sviluppatori scrivono il codice sorgente seguendo le specifiche di progetto, standard di coding e best practice. Include unit testing durante lo sviluppo e commit in repository git. L'importanza di questa fase é per l'appunto la trasformazione da design a eseguibile, con enfasi su qualitá e leggibilitá.

*** 6. Integrazione
**Obiettivo:** Collegare i diversi moduli e testare il sistema completo.
**Descrizione:** SI assemblano i moduli/test unitari in un sistema coerente, verificando integrazioni tramite test di integrazione. Identifica e risolve difetti di interfaccia. Culmina in unn  prototipo parziale o completo pronto per essere testato.

* Qual é la manutenzione piú frequentemente utilizzata?
La manutenzione piú frequentemente utilizzata é quella **correttiva**.
La manutenzione correttiva é l'insieme delle attivitá volte a correggere difetti, errori o malfunzionamenti riscontrati nel software dopo il suo rilascio in produzione, ripristinando la funzionalitá conforme alle specifiche originali.

** Altri tipi di manutenzioni
**** Adattiva
Modifiche al software per adattarlo ai cambiamenti dell'ambiente operativo.

**** Perfettiva
Migliora le prestazioni o aggiunge nuove funzionalitá per soddisfare le richieste degli utenti.

**** Preventiva
Effettuare modifiche per ridurre richi di guasto o per prevenire dei problemi futuri.

* Regola 10-90
La regola 10-90 é una variante della regola 90-90, un aforismo umoristico dell'ingegneria del software.
Questa regola afferma che: "Solo il 10% del codice critico consuma il 90% delle risorse di esecuzione o sviluppo".
Il 10% del codice in questione si definisce **core** del programma.

* Stima durata progetto
Per stimare la durata totale di un progetto software partendo dal documento di specifica, é necessario utilizzare tecniche di pianificazione e stima che si basano su dioversi fattori come la dimensione stimata del prodotto, le risorse disponibili e i processi di sviluppo.
La prima fase della stima é quella stimare le dimensioni totali del software. usando tecniche note che vedremo avanti.
Successivamente si stima la durata:
1. Modello algoritmico **COCOMO:**
   - Stimando effort e poi tempo
2. Usando metodi empirici:
   - Suddividere il progetto in attivitá specifiche e stimare la durata di goni attivitá e successivamente sommare tutte queste stime per averne una complessiva.

* Organizzazione modello di qualitá del Software
Il modello di qualitá del software si strutturs principalmente attorno allo standard **IEEE 1061**, che fonrnisce un framework sistematico per definire, misurare e valutare la qualitá attraverso metriche quantitative legate a obiettivi specifici del progetto.

** Principi e struttura secondo IEEE 1061
Lo standard organizza la qualitá del software identificando prima gli obiettivi di qualitá rilevanti per il contesto.
Successivamente, associa a questi obiettivi attributi di qualitá misurabili e metriche per valutarli.
Un elemento centrale sono gli indici di qualitá, che aggregano piú metriche in indicatori sintetici per monitorare le prestazioni complessive.
Questi indici si divono in tre gruppi principali, allineati al modello McCall.

*** 1. Attivitá di Revisione
- **Manutenibilitá:** effort richiesto per individuare e correggere un errore in un programma operativo.
- **Flessibilitá:** effort per modificare un prodotto software giá in uso.
- **Testabilitá:** effort per testare il software e verificarne la correttezza funzionale.

*** 2. Attivitá di Transizione
- **Portabilitá:** effort per traferire il software ad un nuovo ambiente hardware/software.
- **Riusabilitá:** grado in cui parti del software possono essere riutilizzate in altre applicazioni.
- **Interoperabilitá:** effort per integrare il software con altri sistemi.
- **Evolutivitá:** effort per aggiornarlo con nuovi requisiti.

*** 3. Attivitá di Operazioni
- **Correttezza:** misura in cui il software soddisfa specifiche e obiettivi utente.
- **Affidabilitá:** probabilmente che svolga le funzioni previste con la precisione richiesta.
- **Efficienza:** risorse di calcolo e codice necessarie per eseguire una funzione.
- **Integritá:** protezione da accessi non autorizzati a software o dati.
- **Usabilitá:** effort per imparere, usare, preparare input e interpretare output.

*** Attributi di qualitá
Oltre aghli indici, **IEEE 1061** elenca attributi fondamentali, come:
- **Complessitá:** comprensibilitá e verificabilitá degli elementi e delle loro interazioni.
- **Precisione:** accuratezza dei calcoli e e risultati.
- **Completezza:** implementazione esaustiva delle funzionalità richieste.
- **Coerenza:** uniformità di design, implementazione e notazioni.
- **Tolleranza:** capacità di operare in condizioni avverse.
- **Tracciabilitá:** legami chiari tra elementi del processo di sviluppo.
- **Espandibilitá:** possibilità di ampliare memorie o funzioni.
- **Generalitá:** ampiezza delle applicazioni potenziali.
- **Modularitá:** indipendenza dei moduli.
- **Autodocumentazione:** presenza di documentazione inline.

Questi attribuit sono mappati su metriche concrete

*** Processo iterativo di valutazione
IEEE 1061 definisce un ciclo chiaro:
1. **Definizione degli obiettivi:** contestualizzati al progetto.
2. **Identificazione degli attributi:** selezione di quelli prioritari.
3. **Scelta metriche:** quantitative e rilevanti per ciascun attributo.
4. **Misurazione:** calcolo e confronto con benchmark o target.
5. **Analisi e Feedback:** miglioramento continuo basato sui risultati.

Questa struttura garantisce che la qualitá sia oggettiva, misurabile e allineata agli stakeholder, riducendo soggettivitá e rischi.

* Factory Method, a che cosa serve?
Lo scopo dell'utilizzo del Design Pattern **Factory Method** é quello di definire un'interfaccia per la creazione di un oggetto, che consenta di decidere a running time quale specifico oggetto istanziare.

** Quali sono le situazioni in cui si applica il Design Pattern Factory Method?
- Una classe vuole che le sue sottoclassi scelgano gli oggetti da creare
- Quando una classe non é in grado di sapere in anticipo le classi di oggetti che deve creare
- ecc...

** Quali sono le conseguenze dell'applicazione di questo Design Pattern?
L'utilizzo di questo Design Pattern elimina la necessitá di riferirsi a classi dipendenti dall' applicazione all'interno del codice

* Design Pattern
** Cosa sono i Design Patterns? a cosa servono?
Uno dei compiti più difficili per un progettista di software è individuare un insieme di oggetti ben definiti, riusabili il più possibile e con relazioni e gerarchie chiare ed efficaci.
I Design Patterns sono proprio la soluzione a questo problema.
Questi trovano il fulcro della soluzione ad un problema ricorrente e fanno in modo che possa essere riutilizzata infinite volte anche non applicandola necessariamente nello stesso modo.
In particolare essi creano un linguaggio condiviso tra gli sviluppatori in modo tale da offrire soluzioni a problemi che ritornano spesso nello sviluppo software e creano un codice strutturato in modo corretto.
Inoltre capitalizzano l'esperienza della progettazione OO e ne favoriscono il riuso.
Le soluzioni che propongono non sono mai già note ma allo stesso tempo non sono neanche soluzioni universali e quindi non sono sempre applicabili a qualsiasi problema.

I Pattern si distinguono in tre categorie principali:
- **Creazionali:** Riguardano la creazione degli oggetti.
- **Strutturali:** Si concentrano sull'organizzazione di classi e oggetti.
- **Comportamentali:** Descrivono come gli oggetti interagiscono e come si distribuiscono le responsabilitá.

** Come è fatta la struttura di un Design Patterns?
Un Design Patterns ha la seguente struttura:
Per prima cosa troviamo il nome e la classificazione che illustrano l'essenza, lo scopo e il raggio d'azione del Pattern.
In seguito troviamo la motivazione ovvero una descrizione del problema e dello scenario al quale bisogna applicare il relativo Pattern.
In seguito troviamo l'applicazione del Pattern e subito dopo la struttura cioè una descrizione grafica della configurazione degli elementi che risolvono il problema.
Troviamo anche le classi, gli oggetti che ne fanno parte e i risultati dopo l'applicazione di tale Pattern (conseguenze).
Sono presenti poi alcune tecniche e consigli per applicare il Pattern (implementazione).
Infine troviamo dei codici d'esempio che illustrano come implementare il Pattern in un certo linguaggio, degli esempi di applicazioni reali che lo utilizzano e altri Pattern che sono collegati a questo.

- **Nome e Classificazione:** Il nome illustra l'essenza di un Pattern; la classificazione lo identifica in termini di scopo e raggio d'azione.
- **Motivazione:** Scenario che descrive in modo astratto il problema al quale applicare il Pattern.
- **Applicabilità:** Applicazioni del Pattern.
- **Struttura:** Descrive graficamente la configurazione di elementi che risolvono il roproblema.
- **Partecipanti:** Classi ed oggetti che fanno parte del Pattern.
- **Conseguenze:** Risultati dopo l'applicazione del Pattern.
- **Implementazione:** Tecniche e suggerimenti per applicare il Pattern.
- **Codice di esempio:** Frammenti di codice che illustrano come implementare in un certo linguaggio di programmazione il Pattern.
- **Usi noti:** Esempi di applicazioni in sistemi reali.
- **Pattern collegati:** Altri Pattern.

** Lista dei Design Patterns spiegati dal prof con spiegazione
*** Abstract Factory
**il suo scopo è fornire un'interfaccia per creare famiglie di oggetti correlati**, senza specificare le concrete classi da usare.
I **vantaggi** di usare questo Pattern sono **l'isolamento delle classi complete e la facile sostituzione dell'intera famiglia dei prodotti**.
Lo **svantaggio** di questo Pattern è che **aggiungere nuove famiglie richiede modifiche all'interfaccia della factory**.

*** Factory Method
**il suo scopo è quello di definire un metodo che rimanda alle sottoclassi la decisione su quale oggetto istanziare.**
**Tipico nei framework:**
- La classe astratta fornisce il flusso operativo.
- Le sottoclassi decidono cosa creare
**Benefici: disaccoppia il codice dal tipo concreto degli oggetti.**

*** Adapter
**Il suo scopo è convertire l'interfaccia di una classe esistente incompatibile con un client, in una compatibile.**
Ne esistono due tipi:
- **Object Adapter:** Usa la composizione.
- **Class Adapter:** Usa l'ereditarietá multipla.

*** Composite
**il suo scopo è trattare oggetti semplici e strutture composte in maniera uniforme.**
Ha 3 componenti principali:
- Component (interfaccia comune),
- Leaf (oggetti semplici),
- Composite (oggetti composti).
I **vantaggi** di questo Pattern sono che **semplifica il codice client e facilita l'aggiunta di nuove forme.**
Lo **svantaggio** è che **il sistema può risultare troppo generico.**

*** Decorator
**Il suo scopo è quello di aggiungere dinamicamente delle funzionalità ad un oggetto senza modificarne la classe.** Un esempio di applicazione è la realizzazione di interfacce utente, in cui funzionalità come lo scorrimento del testo o un bordo devono essere aggiunti a livello di singolo oggetto.
Il **decorator** è un oggetto contenitore che racchiude un oggetto elementare e aggiunge una particolare responsabilità. Il **decorator** trasferisce le richieste all'oggetto decorato ma può svolgere funzioni aggiuntive prima o dopo il trasferimento della richiesta.
Si applica quando è necessario aggiungere agli oggetti funzionalità a _runtime_ e quando il subclassing non è adatto (provocherebbe l'esplosione di sottoclassi per ogni funzionalità).

*** Observer
**Il suo scopo è quello di definire una dipendenza uno a molti tra oggetti.** Quando più oggetti dipendono dallo stato di un altro oggetto, bisogna assicurarsi che questi oggetti si aggiornino automaticamente.
È necessario quando un oggetto (detto **Subject** o **Observable**) deve informare automaticamente altri oggetti (**Observer**) ogni volta che cambia stato.
Il Pattern Observer prevede che gli osservatori si registrino presso l'oggetto osservato. In questo modo l'oggetto osservato notifica ogni cambiamento agli osservatori. Quando l'osservatore rileva la notifica può interrogare l'oggetto osservato o svolgere operazioni indipendenti dallo stato dell'osservato. Si applica quando una azione può essere scomposta in due ambiti, ciascuno incapsulato in oggetti separati e quando bisogna gestire le modifiche di oggetti in seguito alla variazione di un altro oggetto.
L'accoppiamento tra **subject** e **observer** è astratto, il subject conosce solo la lista degli osservatori e la _notifica_ avviene in modalità broadcast, quindi il subject non si occupa di quanti sono gli observer registrati.

*** Template Method
**Ha lo scopo di definire la struttura di un algoritmo, delegando alle sottoclassi l'implementazione di passaggi specifici.**
La classe base decide come è organizzato l'algoritmo, le sottoclassi decidono come implementare i passaggi variabili

Si usa:
- quando implementiamo algoritmi che condividono la stessa struttura ma differiscono in alcuni dettagli
- quando si vuole evitare duplicazioni di passaggi perché ci sono comportamenti comuni (vengono inseriti nel template)

La classe base (_AbstractClass_) contiene:
- templateMethod: definisce la sequenza di passi dell'algoritmo
- metodi astratti che le sottoclassi devono implementare
- metodi hook che hanno un comportamento standard, ma le sottoclassi possono anche ridefinire Il template Method crea una struttura di controllo invertito dove è la classe padre che richiama le operazioni ridefinite nelle sottoclassi.

Simile al factory method perché invoca metodi astratti tramite interfaccia e l'implementazione dei metodi rimandata a classi concrete.
Si utilizzano però in problemi diversi:
- il template method è il metodo che invoca i metodi astratti per generalizzare un algoritmo
- il factory method è un metodo astratto che deve creare e restituire l'istanza di classe concreta per sganciare il cliente dalla scelta del tipo specifico

*** Strategy
**Ha lo scopo di definire ed incapsulare una famiglia di algoritmi in modo da renderli intercambiabili indipendentemente dal client che li usa.**
Pensiamo alla classe degli algoritmi di ordinamento, in cui ne esistono diversi (BucketSort, QuickSort ecc). Costruiamo un'applicazione che li supporti tutti e che permette una scelta rapida dell'algoritmo.
Molte classi differiscono solo per il comportamento. Il Pattern **strategy** offre un modo per avere un interfaccia comune. Questo Pattern è applicabile quando sono necessarie più varianti di uno stesso algoritmo, in base al tipo di dato in ingresso o a delle condizioni operative.
La strategy elimina i blocchi condizionali necessari se tutti i comportamenti fossero in un unica classe, ma i client devono conoscere le diverse strategie.
